# Schemes

This is an attempt to start using some ideas from Algebraic Geometry and Algebraic Topology among others in Pure Mathematics in computation with the belief that ideas from pure mathematics allow great representation power. Also, in order for computers to be able to do good pure mathematics (other than proofs), there needs to be a layer of framework that uses these ideas to write programs (in data structures and their interactions). This is a work in writing some of such infrastructure in Haskell.

### Chapter 1 Assignments
The axiom of choice (https://en.wikipedia.org/wiki/Axiom_of_choice) is an important idea while dealing with collections of uncountably many objects. Informally it says that we can instantly find the element that we like the most even though there might not be a way to order every element according to our liking. This is an assumption made to be able to work with specific elements within uncountable collections. Another informal way to say it is that we choose an element to work with and we may use another if we choose to, like the idea of updating one's belief according to Bayes's Theorem. 
In computation infinities do not exist, unless you have Lazy Evaluation and Pattern Matching which a functional programming language like Haskell provides. So, first up we sort of use the idea of the axiom of choice and say that an answer can be assigned to a question, and we can change the assignments if we choose to. It's also like in Physics if you think about it that way, I get a more precise reading of the length of a wire using something like Micrometer Screw Gauge than when I use a 15 centimeter rule. But I can never know a value with infinite precision. So I assign the value that I believe is the best with the resources that I have, to be the reading; which I could update.

#### Schemes
The notion of schemes  in Algebraic Geometry sort of describes the idea that there are a collection of questions and a collection of answers and we assign answers to questions. We can combine two questions to produce new questions and the effect of that is reflected on the variation of answers. In haskell we can build a data type called Scheme that takes a list of questions and a list of answers. For the first implementation, a question can be taken as a linear polynomial equation in one variable represented by a tuple of 2 Ints representing the coefficients of the polynomials, and an answer can be taken as the solution to the equation represented by a tuple of 1 Floating. We can then build an assign function which takes a Scheme and produces an assignment of the answers to the questions represented by a list of tuples of Int, Int, Float.

#### Homotopy of Schemes
We would then like to perform transformations on the questions producing new questions and transformations on the answers producing new answers, and check if the the answers are assigned to the same questions as before. If there was a way to construct transformations that would change the questions and the answers in a way that the answers are associated to the same questions, we would have a mechanism to produce new questions and answers to new questions. And with lazy evaluation and we can seemingly asbtract representations of a set of questions and answers that can be used to generate other questions and answers. The motiviation for this idea comes from Homotopy in Algebraic Topology.

UNDER CONSTRUCTION

